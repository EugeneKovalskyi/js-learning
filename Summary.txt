\\\\\\\\\\\\\\\\\
1.   ЗАПОМНИТЬ   
\\\\\\\\\\\\\\\\\

>>  Для хранения number выделяется 64 бита: 52 - для чисел, 11 - для положения десятичной точки, 1 - для знака

>>  Object.is(NaN, NaN)   // true
>>  Object.is(0, -0)      // false
>>  NaN === NaN           // false
>>  null == undefined     // true   // Равны друг другу и не равны любому другому значению
>>  null > 0              // false  
>>  null == 0             // false  
>>  null >= 0             // true   
>>  undefined > 0         // false  // undefined преобразуется в NaN
>>  'some' > 'string'     // false  // Строки сравниваются посимвольно

>>  1 / 3                 // 0.3333333333333333
>>  10 / 3                // 3.3333333333333335 (округляет до ближайшего возможного согласно формату IEEE 754)
>>  NaN ** 0              // 1
>>  1 / 0                 // Infinity
>>  1 / 4                 // 0.25
>>  "str" / 2             // NaN (При любых математических операциях со строками вернет NaN, кроме +)
>>  1 + NaN               // NaN
>>  1 + '2'               // '12'
>>  '2' - 1               // 1
>>  true + false          // 1
>>  true + true           // 2
>>  undefined + undefined // NaN
>>  null + null           // 0
>>  NaN + NaN             // NaN
>>  [] + []               // '' (пустая строка)

>>  typeof(Math)          // object 
>>  typeof(null)          // object
>>  typeof(alert)         // function

>>  String(true)          // "true"
>>  String(null)          // "null"
>>  String(undefined)     // "undefined"

>>  Number(undefined)     // NaN
>>  Number(null)          // 0

>>  Boolean('0')          // true
>>  Boolean('')           // false
>>  Boolean(NaN)          // false
>>  Boolean(null)         // false
>>  Boolean(undefined)    // false

>> a ^ b ^ b === a
>> ~n === -(n + 1)
>> ' a << n ' === a * 2**b
>> ' a >> n ' === a / 2**b (крайний-левый бит (знак числа) не меняется)

>>  Область видимости `var` ограничивается функцией
>>  if (false) var phrase - переменная phrase создасться, поскольку объявления var всплывают в начало фу-и
>>  == и Boolean() используют разные правила приведения типов

>>  Полифил - аналог метода в спецификации, который не поддерживается в более старой версией движка
>>  Инкапсуляция - разделение интерфейса на внутренний и внешний


\\\\\\\\\\\\\\\\\\\\\\\\\\\\
2.   Основные типы данных   
\\\\\\\\\\\\\\\\\\\\\\\\\\\\

      1. Number (спец. числовые значения: Infinity, -Infinity, NaN)                     

      2. BigInt (для работы с целыми числами произвольной длинны; добавить n в конце числа)

      3. String

      4. Boolean

      5. Null         

      6. Undefined

      7. Symbol

      8. Object

>> Виды записей переменных:
      1. PascalCase - типы и классы
      2. DB_PASSWORD - константные значения
      2. camelCase - все остальное
  
>> Унарный ' + ' не работает с BigInt числами

>> Ṩ === 'S\u0307\u0323' (Ṩ === S + точка сверху + точка снизу)


\\\\\\\\\\\\\\\\\\\\\\\\\\\\
3.   Преобразование типов   
\\\\\\\\\\\\\\\\\\\\\\\\\\\\

      1.  Строковое (String(value))
      2.  Числовое (Number(value), '6' / '2' = 3)
      3.  Логическое (Boolean(value))


\\\\\\\\\\\\\\\\\
4.   Операторы   
\\\\\\\\\\\\\\\\\

- унарные
- бинарные
- сравнения
- логические


++value   > возвращает новое значение

value++   > возвращает старое значение

==        > преобразуют операнды к числу

===       > проверяет равенство без приведения типов

||        > возвращает первое истинное значение, либо последнее при всех false

||=       > Логическое присваивание ИЛИ - если операнд слева falsy, то ему присваивается операнд справа

&&        > возвращает первое ложное значение, либо последнее при всех true

&&=       > Логическое присваивание И - если операнд слева truthy, то ему присваивается операнд справа

??        > Оператор нулевого слияния (Nullish coalescing operator) - возвращает первый аргумент,
            если он не null/undefined. Запрещено использовать с && и ||
            result = a ?? b - эквивалент записи - result = (a !== null && a !== undefined) ? a : b

??=       > Оператор нулевого присваивания - если операнд слева undefined/null, то ему присваивается операнд справа

?.        > Оператор опциональной последовательности 
            (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining)


>> Побитовые операторы работают с 32-битными целыми со знаком, старшим битом слева и дополнением до двойки:
      - страший бит слева - от большего разряда к меньшему
      - дополнение до двойки - в отрицательных числах биты противоположны положительным числам и добавлена 1

>> obj.method() - оператор . возвращает Reference Type (ссылочный тип), который передает оператору () информацию о this.
      Если оператор . используется в каком-либо выражении отдельно от оператора (), то Reference Type теряет исходный this.
      Одним из решений данной проблемы является метод bind().

>> Оператор Spread - копирует собственные перечисляемые свойства объекта (без прототипа) в новый объект:
      let obj = { a: 1, b: 2 }
      let newObj = { ...obj }


\\\\\\\\\\\\\
5.   Циклы   
\\\\\\\\\\\\\

>> Циклы игнорируют СИМВОЛЬНЫЕ и НЕПЕРЕЧИСЛИМЫЕ свойства объектов

>> Директивы break/continue поддерживают метки, чтобы выйти из любого уровня вложенности циклов:
      labelName: for (...) {
        ...
        break/continue labelName;
      }


\\\\\\\\\\\\\\\
6.   Функции   
\\\\\\\\\\\\\\\

      1. Function Declaration                          : function foo() {} 
            > В Lexical Environment инициализируется мгновенно и полностью
      
      2. Function Expression                           : let foo = function() {} 
            > Не имеет        this
            > Не имеет        super
            > Не имеет        "arguments"
            > Не могут        быть вызваны с new

      3. Named Function Expression (NFE)               : let foo = function bar() {} 
            > Function Expression с именем 
            > Для рекурсивных вызовов 
            > Недоступна за пределами фу-и;

      4. new Function([arg1, ..., argN], functionBody) : let foo = new Function('a', 'b', 'return a + b')
            > Имеет [[Environment]], ссылающийся на глобальное лексическое окружение

      5. Шаблонные функции - foo`some text and ${arg1} and ${arg2}`


>> new.target - исп. внутри фу-и, чтобы проверить вызвана ли фу-я при помощи new
>> isNaN() и isFinite() отличаются от Number.isNaN() и Number.isFinite()
>> Object.is() идентичен === , кроме 2-х случаев
>> parseInt('100px', 10) === 100
>> str.codePointAt(pos) // код символа на позиции pos
>> String.fromCodePoint(code)
>> foo.name - имя фу-и
>> foo.length - ко-во аргументов в объявлении фу-и. Остаточные параметры не считаются
>> call  - принимает список аргументов
>> apply - принимает псевдомассив
>> bind  - возвращает экзотический объект bound function, который фиксирует контекст и аргументы только во время создания
>> [].join.call(arguments) // пример заимствования метода с помощью call
>> window.eval(str) - выполняет строку кода str и возвращает результат последнего line. 
                      При `use strict` имеет свое lexical environment.


>> Контекст выполнения - спец. внутренняя структура данных, которая содержит информацию о вызове фу-и 
    (место логического курсора, локальные переменные фу-и, значение this и пр.)

>> Применение рекурсии:
      - рекурсивные обходы (объект в объекте в объекте...)
      - рекурсивные структуры (связанный список)

>> arguments - подобный массиву объект содержащий ВСЕ переданные в фу-ю аргументы, не поддерживает методы массивов. 

>> Lexical Environment - объект спецификации: он описан в спецификации для описания того, 
                         как все работает, его нельзя получить

>> Переменная - свойство спец. внутр. объекта Environment Record (хранилище переменных).
                Поиск искомой переменной происходит сначала во внутреннем Lexical Environment, 
                затем во внешнем, и так до глобального объекта

>> Вложенный setTimeout гарантирует фиксированную задержку после выполнения фу-и

>> Браузер ограничивается 4 мс минимальной задерожки между более 4 вызовов setTimeout или setInterval

>> Декораторы (Decorators) - обертка вокруг фу-и, которая изменяет ее поведение

>> Частичное применение - создание новой фу-и с некоторыми фиксированными аргументами (double = multiple.bind(null, 2))

>> Каррирование - трансформация фу-и из f(a,b,c) в f(a)(b)(c). 
                  Можно создавать частично-примененные фу-и (т.к. каждый аргумент запоминает свою обл. видимости).
                  Только для фу-й с фиксированным количеством аргументов.


\\\\\\\\\\\\\\\
7.   Объекты    
\\\\\\\\\\\\\\\

>> null и undefined НЕ имеют объектов-оберток. У них нет: свойств, методов, прототипов

>> Все ключи объектов преобразуются в строки (кроме символов и строк)

>> this - указывает на объект перед точкой

>> ?. - опциональная цепочка (optional chaining) - останавливает вычисление и возвращает undefined,
        если значение слева === undefined или === null 
        - работает только с объявленными объектами
        - работает только для ЧТЕНИЯ и УДАЛЕНИЯ
        - работает для вызова фу-и, которой может не существовать ( obj.method?.() )
        - работает для объектов со свойствами в квадратных скобках ( obj?.[prop] )

>> [Symbol.iterator]() {} - спец. метод объекта для настройки итерации объекта "вручную". Возвращает объект с методом next(),
                            который вызывается на каждой итерации 

>> Варианты преобразования типов (хинты): 1. "string"
                                          2. "number"
                                          3. "default"

>> [Symbol.isConcatSpreadable]: true - спец. свойство объекта, которое указывает методу array.concat(obj) обрабатывать obj как массив
                                       * Пример:
                                                let array = [1, 2]
                                                let obj = { 0: 'someValue', 1: 'anotherValue' }
                                                ( array.concat(obj) ) // 1, 2, someValue, anotherValue

>> [Symbol.toStringTag]: 'Value' - спец. свойство объекта для настройки toString у объектов.
                                   Это свойство есть у большей части встроенных объектов.
                                   Результат === значение этого свойства обернутое в [object Value]

>> Дескриптор свойства - объект, который содержит значение и флаги (атрибуты) свойства
>> Атрибуты дескриптора для date properties: 
      - value 
      - writable        === false, value нельзя изменить
      - enumerable      === false, свойство игнорируется циклом, Object.keys
      - configurable    === false, нельзя удалить, нельзя изменить значение всех атрибутов с false на true

>> Object.getOwnPropertyDescriptor(obj, propName)       - возвращает дескриптор свойства
>> Object.getOwnPropertyDescriptors(obj)                - возвращает объект, содержащий дескрипторы всех свойств
>> Object.defineProperty(obj, propName, descriptor)     - возвращает obj
>> Object.defineProperties(obj, { prop: descriptor })   - возвращает obj
>> let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj)) - клонирование объекта вместе с флагами


>> Типы свойств:
      - Data properties (свойства-данные)
      - Accessor properties (свойства-аксессоры) 

>> Accessor properties - фу-и, которые исп. для получения и присвоения значения, но синтаксически выглядит как свойство объекта
      let obj = {
            get propName() {}       - срабатывает при чтении obj.propName
            set propName(value) {}  - срабатывает при записи obj.propName = value 
      }
  
>> Атрибуты дескриптора для accessor properties:
      - get            // { get() { return this.name } }
      - set            // { set(value) { this.name = value } }
      - enumerable
      - configurable


>> Intl - объект c API интернационализации:
      > let collator  = Intl.Collator([locales, [options]])
      > let formatter = Intl.DateTimeFormat([locales, [options]])
      > let formatter = Intl.NumberFormat([locales, [options]])
  
>> Сильная ссылка - ссылка на объект, которая предотвращает его удаление сборщиком мусора
>> Слабая ссылка  - ссылка на объект, которая НЕ предотвращает его удаление сборщиком мусора
  
>> new WeakRef(target) - объект, содержащий слабую ссылку на target
>> new FinalizationRegistry(cleanuCallback) - объект, который позволяет привязять к target колбэк очистки, 
                                                который выполниться после удаления target из памяти сборщиком мусора.


\\\\\\\\\\\\\\\\\
8.   Прототипы   
\\\\\\\\\\\\\\\\\

>> [[Prototype]] - скрытое свойство, либо === null, либо ссылается на другой объект - прототип
      - Замена [[Prototype]] в существующих объектах ОЧЕНЬ медленная операция ( Object.setPrototypeOf и obj.proto = )

>> obj.__proto__ - это getter/setter для [[Prototype]], то есть способ доступа до

>> Операции запись/удаление не работают с прототипом (за исключением свойства-аксессора setter)

>> this - указывает на объект перед точкой

>> Циклы учитывают унаследованные свойства
>> Object.keys, Object.values и др. - игнорируют унаследованные свойства

>> Foo.prototype = {}/null - определяет __proto__ только для экземпляров new Foo
      function Foo() {} > Foo.prototype = obj2 > let obj1 = new Foo() > obj.__proto__ === obj2
>> Foo.prototype === { constructor: Foo }
>> obj.__proto__ === arr.__proto__.__proto__ === func.__proto__.__proto__ === Number(5).__proto__.__proto__ === Object.prototype

>> obj.join = Array.prototype.join // пример заимствования метода с помощью prototype

>> Вместо __proto__ : 1. Object.create(proto, [descriptor])       // создает {} со свойством [[Prototype]] и дескриптором
                      2. Object.getPrototypeOf(obj)               // возвращает [[Prototype]]
                      3. Object.setPrototypeOf(obj, proto)        // устанавлиавает [[Prototype]]

>> let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))

>> Простейший объект (ассоциативный массив) - создается через new Map / Object.create(null) / obj.__proto__ = null 

>> obj['__proto__'] = 'someValue' // присвоение проигнорируется


\\\\\\\\\\\\\\
9.   Классы   
\\\\\\\\\\\\\\

>> Класс - шаблон кода для создания объектов, который устанавливает в них начальные свойства и методы

>> [[IsClassConstructor]]: true - спец. внутр. свойство фу-и, созданной с помощью class 
>> Методы и constructor - сохраняются в SomeClass.prototype
>> Методы класса неперечисляемы
>> Классы всегда используют 'use strict'
>> (Named) Class Expression - аналог (Named) Function Expression

>> class Child extends Parent : 
      - Child.prototype.__proto__ === Parent.prototype
      - после extends разрешены любые выражения

>> super.method() - вызывает родительский метод
>> super()        - вызывает конструктор родителя (работает только в дочернем конструкторе)

>> При отсутсвии конструктора, вызывается пустой конструктор ( constructor(...args) { super(...args) } )
>> Конструкторы в дочерних классах должны обязательно вызывать конструктор родителя ( super() ) перед использованием this 
>> [[ConstructorKind]]: 'derived' - спец. внутр. свойство функции-конструктора дочернего класса.
                                    Такой конструктор ожидает вызова конструктора родительского класса,
                                    который создаст пустой объект и присвоет его this.
                                    Поэтому, если мы создаем конструктор в дочернем классе, необходимо вызвать super,
                                    иначе объект для this не будет создан и мы получим ошибку.

>> Родительский конструктор всегда использует СВОЕ ЗНАЧЕНИЕ ПОЛЯ, а не переопределенное дочерним классом
>> Поля РОДИТЕЛЬСКОГО класса инициализируются перед конструктором
>> Поля ДОЧЕРНЕГО класса инициализируются после вызова super

>> [[HomeObject]] : 
      - спец. внутр. свойство методов класса (объекта) и оно равно этому классу (объекту)
      - используется только в super, чтобы получить прототип родителя и его методы
      - нельзя изменить, поэтому копировать метод использующий super, между объектами небезопасно
      - в объектах работает только в методах объявленных как method()

>> Статические свойства и методы класса - устанавливаются самому классу:
      - наследуются дочерним классом ( Child.[[Prototype]] = Parent ) 
      - НЕ наследются от встроенных классов
      - this === сам класс ( по аналогии с объектами )
      - экземплярам класса НЕДОСТУПНЫЕ
      - СИНТАКСИС: 
            1. class MyClass {
                  static property = ...
                  static method() { ... }
            };

            2. MyClass.property = ...
               MyClass.method   = ...
              
>> Защищенные методы и свойства - по соглашению JS-программистов:
      - доступны только внутри класса
      - начинаются с префикса ' _ '

>> Приватные методы и свойства:
      - начинаются со спец. символа ' # '
      - доступны исключительно внутри класса
      - не наследуются
      - не конфликтуют с публичными
      - не работает с this ( this['#prop'] - не работает )

>> Symbol.species - спец. статический getter, который должен вернуть конструктор,
                    который будет использован для создания новых объектов:
                    * Пример: 
                        class ExtendedArray extends Array {
                              static get [Symbol.species]() { return Array }
                        }           
                        let array = new ExtendedArray(1, 2, 3, 4, 5)
                        let filteredArray = array.filter(item => item >=3)
                        ( filteredArray.__proto__ === array.__proto__ ) // false
      
>> instanceof - оператор проверяет, принадлежит ли объект указанному классу, с учетом наследования
                Алгоритм работы: 
                        1. Если в классе есть статичный метод [Symbol.hasInstance], то вызвать его ( должен возвращать true/false):
                              * Пример:
                                    class Animal {
                                          static [Symbol.hasInstance](obj) { if (obj.catEat) return true }
                                    }
                                    let obj = { catEat }
                                    ( obj instanceof Animal ) // true

                        2. Проверка на равенство прототипа класса какому либо прототипу в прототипной цепочке объекта: 
                              ( Class.prototype === obj.__proto__ )
                              ( Class.prototype === obj.__proto__.__proto__ ) и т.д.

>> objA.isPrototypeOf(objB) - аналог instanceof: ( obj instanceof Class === Class.prototype.isPrototypeOf(obj) )

>> Примеси (Mixins) - класс, методы которого предназначены для расширения функциональности других классов без наследования от примеси.
                    - Примесь необходимо скопировать в прототип расширяемого класса ( Object.assign(ClassName.prototype, mixin) )
                    - Примесь перезаписывает существующие методы класса

>> JavaScript НЕ поддерживает множественное наследование. Вместо него используют Mixins


\\\\\\\\\\\\\\\\\\\\\\\\\
10.  Тип данных Symbol  
\\\\\\\\\\\\\\\\\\\\\\\\\

      1. Symbol.for(key) 
      2. Symbol.keyFor(symbol)
      3. Object.getOwnPropertySymbols(obj)
      4. Reflect.ownKeys(obj)
      5. Symbol.toPrimitive

>> Свойства, чьи ключи Символы игнорируются циклом for...in и Object.keys()


\\\\\\\\\\\\\\\\\
11.  Замыкание   
\\\\\\\\\\\\\\\\\

>> Замыкание - это фу-я, которая с помощью скрытого свойства [[Environment]] запоминает свои внешние переменные
               и может получить к ним доступ. ( https://learn.javascript.ru/closure )
               

\\\\\\\\\\\\\\\\\\\\\\\\
12.  Обработка ошибок
\\\\\\\\\\\\\\\\\\\\\\\\

>> try {} catch() {} finally {} - работает синхронно, то есть ассинхронный код игнорируется
      - finally выполняется всегда, в т.ч. после return 
      - при возникновении ошибки JS генерирует объект ошибки и передает как аргумент в блок catch
      - catch должен обрабатывать только известные ему ошибки, а остальные пробрасывать ( throw error )

>> throw <объект ошибки> - оператор генерирующий ошибку

>> window.onerror = function (message, url, line, column, error) {} - глобальный catch

>> Сервисы для логирования ошибок:
      - https://errorception.com
      - http://www.muscula.com

>> Расширение встроенных классов ошибок:
      - class MyError extends Error
      - вызвать super
      - изменить name ( this.name = this.constructor.name - чтобы не прописывать вручную name)

>> instanceof - использовать для проверки типа ошибок (при расширении классов ошибок)

>> Обертывание исключений - алгоритм: фу-я ловит низкоуровневые исключения и создает 1 высокоуровневое
      

\\\\\\\\\\\\\\\\\\\\\
13.  Асинхронность   
\\\\\\\\\\\\\\\\\\\\\

>> new Promise(function(resolve, reject) { <executor> }).then(function(result) {}, function(error) {})
                                                        .catch(function(error) {})
                                                        .finally(function() {})

      1. executor       - фу-я-исполнитель, которая запускается сразу после создания Promise
      2. resolve(value) - встроенный callback, который необходимо вызвать при успешном выполнении executor
      3. reject(error)  - встроенный callback, который необходимо вызвать при ошибке в executor
      4. Экземпляр обладает внутренними свойствами:
            > state (состояние; может быть изменено только 1 раз): 
                  - pending   (ожидание)
                  - fulfilled (выполнено успешно)
                  - rejected  (выполнено с ошибкой)
            > result (в зависимости от state):
                  - при pending     === undefined
                  - при fulfilled   === value
                  - при rejected    === error
      5. then - возвращает Promise; then выполняет:
            > 1-й callback при state === fulfilled
                  - возвращаемое значение становится результатом выполнения Promise и передается в следующий .then 
            > 2-й callback при state === rejected
      6. catch - укороченный вариант для .then(null, function(error) {})
      7. finally - метод, который:
            > выполнится в любом случае
            > ничего не возвращает
            > пропускет result или error дальше, к следующему then/catch

            
>> Если callback в .then/.catch/.finally возвращает new Promise, последующие элементы цепочки ждут, пока выполнится new Promise

>> thenable - отличительный признак объекта содержащего метод .then, который можно вернуть как Promise.
              Если фу-я возвращает объект с пользовательским методом .then, то интерпретатор обрабатывает его
              как Promise и вызывает его метод .then, после чего передает ему встроенные resolve и reject

>> fetch - возвращает Promise, который возвращает объект response ПОСЛЕ того, как удаленный сервер присылает
           ЗАГОЛОВКИ ответа, но ДО того, как ВЕСЬ ОТВЕТ сервера полностью загружен

>> Скрытым try-catch - обладает фу-я Promise и callback - ошибки обрабатываются по ходу выполнения кода (синхронно)

>> Проброс ошибки (throw) в .catch работает аналогично пробросу в try-catch

>> 'unhandledrejection' - событие, которое срабатывает при наличии необработанных ошибок.
                          Возникает, когда все промисы (микрозадачи) завершены и какой-либо из них "rejected"
                          Основные свойства:
                              - event.promise // [object Promise] - Promise, который сгенерировал ошибку
                              - event.reason  // Объект ошибки, которая не была обработана

>> Методы класса Promise:
    1. Promise.all            - ждет, пока все переданные промисы выполнятся УСПЕШНО (или 1-ю ошибку)
    2. Promise.allSettled     - ждет, пока все переданные промисы ЗАВЕРШАТСЯ
    3. Promise.race           - ждет 1-й ЗАВЕРШЕННЫЙ промис
    4. Promise.any            - ждет 1-й УСПЕШНО выполненный промис
    5. Promise.resolve/reject - возвращает промис успешный/с ошибкой (async-await заменяет эти методы)

>> Промисификация - создание фу-и-обертки, которая принимает в качестве параметра callback
                    и возвращает Promise, который вызывает этот callback

>> PromiseJobs (mikrotask queue) - очередь микрозадач (.then/.catch/.finally попадают в очередь): 
                                   движок выполняет задачи из очереди, когда он выполнит основной код
                                    
>> async - оператор, который пишется перед объявлением фу-и, теперь эта фу-я всегда будет возвращать Promise
            - работает для методов класса
            - для обработки финального результата/ошибки использовать .then/.catch
            
>> await - оператор, который пишется перед Promise в async фу-и, теперь интерпретатор ждет, пока Promise не выполнится
            - работает с thenable-объектами
            - для обработки ошибок использовать try-catch
 
>> Условия для async-итерации:
      1. [Symbol.asyncIterator] - вместо [Symbol.iterator]
      2. next() - должен возвращать Promise
      3. Для итерации по объекту исп. только for await


\\\\\\\\\\\\\\\\\\
14.  Генераторы
\\\\\\\\\\\\\\\\\\

>> function* generateSequence() {         // при вызове возвращает спец. объект - генератор ( [object Generator] )
      yield 1
      yield 2
      return 3 // <!>
   }
   let generator = generateSequence()     // перебираемый объект ( <!> цикл не возвращает значение return )
   generator.next()                       // выполняет код фу-и до ближайшей инструкции ' yield ', после чего останавливается.
                                                Возвращает объект: 
                                                      { value: 'value', done: true/false }
                                                            - true в случае завершения выполнения фу-и ( или return )
      
>> Генераторы можно генерировать бесконечно ( например, с помощью цикла в теле функции-генератора )

>> Для создания перебираемых объектов обычно исп. генератор  - *[Symbol.iterator]
>> *[Symbol.iterator]() {} - сокращенная запись для [Symbol.iterator]: function* () {} 
      
>> yield* - инструкция, которая делегирует выполнение другому генератору
>> Композиция генераторов - возможность встраивать генераторы друг в друга с помощью инструкции ' yield* '
                            * Пример: 
                                    function* generateSequnce(start, end) {
                                          for (let i = start; i !== end; i++) yield i
                                    }
                                    function* generateAnotherSequence() {
                                          yield* generateSequence(1, 5)
                                          yield* generateSequence(5, 10)
                                    }

>> yield и next могут обмениваться значениями:
      - yield передает значение объекту, который возвращает текущий ' next '
      - next(arg) передает arg в генератор, после чего arg становиться результатом предыдущего выражения yield
            * Пример: 
                    console.log(yield 1) // generator.next().value  === 1           // в консоле выведет 4
                    console.log(yield 2) // generator.next(4).value === 2           // в консоле выведет 9
                    console.log(yield 3) // generator.next(9).value === 3           // в консоле выведет 16
                                         // generator.next(16).value === undefined

>> throw - метод инициирующий ошибку на последнем сработавшем yield (generator.throw(new Error()))
       
>> Async-генератор:
      - необходимо добавить async
      - next возвращает Promise 
      - перебирать генератор только с помощью for await 

>> Для создания async-перебираемых объектов обычно исп. async-генератор - async *[Symbol.asyncIterator]


\\\\\\\\\\\\\\
15.  Модули
\\\\\\\\\\\\\\

>> Модуль - файл со скриптом

>> export - отмечает переменные и фу-и, которые должны быть доступны вне модуля
>> import - импортирует функциональность из других модулей

>> Свойства модулей:
      1. В модуле всегда используется режим 'use strict'
      2. Каждый модуль имеет свою обл. видимости
      3. Импортируемый код выполняется 1 раз
      4. Изменения импортируемых данных видят все импортеры
      5. В модуле this === undefined ( в не-модуле this === window )
      6. Модули выполняются в отложенном режиме ( deferred ):
            - модули ожидают полной загрузки HTML
            - сохраняется порядок выполнения скриптов в документе
      7. Модули с одинаковым src выполняется 1 раз
      8. Модуль загружаемый с другого домена требует указания заголовков CORS

>> Рекомендуется явно указывать список импортируемого функционала - для легкой поддержки кода 

>> export default - экспорт по умолчанию: 
      - в модуле может быть только 1 такой экспорт
      - при импорте такого экспорта {} не нужны
      - экспортируемая сущность не обязана иметь имя
      - export { foo as default } - экспорт отдельно от объявления
      - при import * as foo, доступ к export default через foo.default

>> export ... from ... - реэкспорт:
      - позволяет импортировать функционал и одновременно его экспортировать 
      - исп. для возможности импортировать весь функционал из 1 "главного" файла

>> export { default } from ... - реэкспорт по умолчанию

>> import 'module' - запустит код импортируемого модуля

>> import('module') - динамический импорт:
      - загружает модуль и возвращает Promise
      - можно исп. в любом месте кода
      - работает в скрипте не-модуле
      - внутри async фу-и можно исп. await import('module')
      - это НЕ фу-я ( аналог super() )


\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16.  Регулярные выражения
\\\\\\\\\\\\\\\\\\\\\\\\\\\\

>> Создание regexp:
      a. let regexp = new RegExp('шаблон', 'флаги')       // можно использовать переменные
      b. let regexp = /шаблон/флаги                       // только статичный текст
    
>> Флаги:
      i - поиск не зависит от регистра
      g - поиск ищет ВСЕ совпадения (иначе только первое)
      m - многострочный режим (только для якорей ^ и $, чтобы искать в каждой строке разделённых переносом строки \n)
      s - режим dotall ( . === /n)
      u - полная поддрежка Юникода
      y - поиск на конкретной позиции в тексте
      d - результат помещается в массив

>> Символьные Классы:
      \d - цифра (0-9)
      \s - пробельные символы
      \w - буквы латинского алфавита, цифры, _
      \p{...} - юникодные свойства, работает только с флагом u, описывают категорию символа: L, N, P, и т. д. 
            "123 test".match(/\p{L}/gu) === t,e,s,t
      .  - любой символ, кроме \n (с флагом s будет учитывать и \n)
      ^ - начало строки
            /^\d/.test("1. Test") === true
      $ - конец строки
            /st$/.test("2. Test") === true
      ^...$ - полное совпадение строки
            /^test$/.test("test") === true
      \b...\b - ищет слово (начинается на \w, заканчивается не \w)
            "JavaScript Java Script".match(/\bJava\b/g) === Java
      [...] - искать один символ соответствующий какому-либо из переданных (диапазону) символов, символьных классов
      [^...] - искать любые символы кроме указанных
            "abc".match(/[abc])    === a
            "abc".match(/a[a-z]/)  === ab
            "1bc".match(/[^0-9]+/) === bc
      | - альтернация, как [...], но работает не с символами, а с любыми выражениями
            "00:00 10:10 23:59 25:99 1:2".match(/([01]\d|2[0-3]):[0-5]\d/g) === 00:00, 10:10, 23:59

>> Квантификаторы - пишутся после символа, который нужно искать какое-то число раз
      + - 1 и более раз
      * - 0 и более раз
      ? - 0 или 1 раз
      {n} - n раз (после n через кому можно указать дополнительное число раз: {1,2} - 1 или 2 раза)

>> Обратный Символьный Класс - класс, который исключаюет другой соответствующий класс (Например: \D, \S, \W)

>> Методы:
      str.match(regexp) - ищет совпадения 
            - без скобочных групп
            - если совпадений нет, возвращает null

      str.matchAll(regexp) - ищет совпадения
            - со скобочными группами
            - возвращает перебираемый объект (Array.from, чтобы сделать из него массив)
            - если совпадений нет, возвращает пустой перебираемый объект

      str.replace(str|regexp, str|function) - универсальный метод поиска и замены в строке
            - во 2-м аргументе (строка замены) можно использовать спец. символы (см. Подстановки)
            - во 2-м аргументе может быть фу-я - её результат будет вставлен в качестве замены
                  > func(match, p1, ..., pn, offset, input, groups)
                        1. match - найденное совпадение
                        2. p1, ..., pn - содержимое скобочных групп
                        3. offset - позиция, на которой найдено совпадение
                        4. input - исходная строка
                        5. groups - объект с содержимым именованных скобочных групп

    
      str.split(regexp|substr, limit) - разбивает строку по разделителю regexp или substr
      str.search(regexp) - возвращает позицию 1-го совпадения или -1, если совпадений нет                 

      regexp.exec(str) - аналогичен str.match(regexp)
            > при наличии флага g
                  - regexp.lastIndex - позиция начала поиска каждого следующего совпадения
                  - если совпадений больше нет, то regexp.exec(str) возвращает null, а regexp.lastIndex === 0
            > при наличии флага y
                  - regexp.lastIndex - ищет исключительно на позиции lastIndex

      regexp.test(str) - если есть хоть одно совпадение, то возвращает true, иначе false
            !!! имеется свойство regexp.lastIndex
            !!! после использования lastIndex меняется на следующий

>> Для поиска символов [ ] \ ^ $ . | ? * + ( ) необходимо их экранировать

>> Символьные классы - сокращение для наборов символов:
      \d === [0-9]
      \w === [a-zA-Z0-9_]
      \s === [\t\n\v\f\r]

>> Режимы квантификаторов:
      1. Жадный  - повторяет квантификатор максимальное число раз. 
            Если строка закончилась, поиск возвратится до ближайшего совпадения оставшегося шаблона.
            Режим работает по умолчанию.
      2. Ленивый - ищет совпадения для оставшегося шаблона перед каждым повторением квантификатора.
            Режим включается знаком ? после квантификатора.

>> Скобочная группа:
      1. Квантификаторы применяются ко всему содержимому скобок
      2. Скобочные группы поочередно сохраняются в результируюющий массив (номерация начинается с 1):
            - не работает с флагом g
            - если скобочная группа необязательна (квантификатор ?), она все равно будет в результате как undefined
      3. str.matchAll(regexp):
            - возвращает перебираемый объект (Array.from(obj), for (let array of obj), [array1, array2] = obj)
            - с флагом g каждое совпадение это массив со скобочными группами
            - если совпадений нет, возвращает пустой перебираемый объект
      4. (?<name>...) - именование скобочной группы
            - именованные группы находятся в array.groups
      5. str.replace(regexp, replacement) - в строке замены replacement можно использовать содержимое скобочных групп:
            - по номеру скобочной группы ( $n )
                  >> 'aaa bbb'.replace(/(\w+) (\w+)/, '$2 $1') === 'bbb aaa'
            - по имени скобочной группы ( $<name> )
                  >> 'a b'.replace(/(?<name1>a) (b)/, '$name1 $name1') === 'a a'
      6. ?: - исключает содержимое скобочной группы из результата
            >> 'a b'.match(/(?:\w) (\w)/)
    
>> Обратные ссылки в шаблоне (доступ к скобочным граппам в шаблоне):
      \number - по номеру скобочной группы
      \<name> - по имени скобочной группы

>> Подстановки (шаблон замены - метод replace):
      $$ - подставляет знак $
      $& - подставляет совпадение полностью 
      $n - подставляет совпадение группы под номером n
      ${name} - подставляет совпадение группы с именем name

>> Проверки:
      - при нескольких проверках подряд для совпадения необходимо выполнение всех проверок
      - чтобы Y был в результате, его необходмо обернуть в скобки
            X(?=Y) - ищет X, если за ним Y
            X(?!Y) - ищет X, если за ним НЕ Y
            (?<=Y)X - ищет X, если перед ним Y
            (?<!Y)X - ищет X, если перед ним НЕ Y


\\\\\\\\\\\
17.  DOM
\\\\\\\\\\\

>> Методы:
      elem.matches(css) - проверяет (true/false) удовлетворяет ли элемент CSS
      elem.closest(css) - ищет ближайшего предка, включая сам элемент
      elemA.contains(elemB) - true, если elemB внутри elemA или elemA === elemB, иначе false 

>> Наборы ссылок:
      > Для всех узлов: childNodes, parentNode, firstChild, lastChild, previousSibling, nextSibling
      > ДЛ элементов: children, parentElement, firstElementChild, lastElementChild, previousElementChild, nextElementChild
    
>> Поиск элементов:
      elem.querySelector(css)
      elem.querySelectorAll(css)
      elem.getElementById(id)
      elem.getElementsByClassName(class) ---|
      elem.getElementsByTagName(tag) -------| --> возвращают коллекцию, которая обновляется при изменениях
      elem.getElementsByName(name) ---------|


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
* * *   Полезный софт   * * *   
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

------------------------------------
* 1. Cache-Wrapper + call + apply 
------------------------------------
let workers = {
   someProp: 10,
    
   someMethod(arg1, arg2) {
   return arg1 + arg2 + this.someProp
   },
}

workers.someMethod = cachingDecorator(workers.someMethod, hash)
    
function hash() {
   return [].join.call(arguments)
}
    
function cachingDecorator(func, hash) {
   let cache = new Map()
    
   return function (...args) {
      let key = hash(arguments)
   
      if (cache.has(key)) return cache.get(key)
    
      let result = func.apply(this, args)
    
      cache.set(key, result)
    
      return result
   }
}

console.log(workers.someMethod(1, 2))


------------------------------------------------------
* 2. Object.prototype.toString - расширенный typeof
------------------------------------------------------

let objToString = Object.prototype.toString

let user           = { [Symbol.toStringTag]: 'User' }       
let array          = []                                     
let number         = 123                                    
let string         = 'str'                                  
let boolean        = true                                   
let nullValue      = null                                   
let functionValue  = alert                                  
let undefinedValue = undefined                              

objToString.call(user)              // [object User]    
objToString.call(array)             // [object Array]
objToString.call(number)            // [object Number]
objToString.call(string)            // [object String]
objToString.call(boolean)           // [object Boolean]
objToString.call(nullValue)         // [object Null]
objToString.call(functionValue)     // [object Function]
objToString.call(undefinedValue)    // [object Undefined]


------------------------------
* 3. Обёртывание исключений
------------------------------

class ReadError extends Error {
      constructor(message, cause) {
        super(message)
        this.cause = cause
        this.name = 'ReadError'
      }
}
    
class ValidationError extends Error {
      constructor(message) {
            super(message)
            this.name = this.constructor.name
      }
}
    
class PropertyRequiredError extends ValidationError {
      constructor(property) {
            super('Absent property: ' + property)
            this.property = property
      }
}
    
function readUser(json) {
      let user
    
      try {
            user = JSON.parse(json)
      } catch (error) {
            if (error instanceof SyntaxError) throw new ReadError(error.name, error)
            else throw error
      }
    
      try {
            validateUser(user)
      } catch (error) {
            if (error instanceof ValidationError) throw new ReadError(error.name, error)
            else throw error
      }
}
    
function validateUser(user) {
      if (!user.age) throw new PropertyRequiredError('age')
      if (!user.name) throw new PropertyRequiredError('name')
    
      return user
}
    
try {
      readUser('{ "name": "k", "age": 25 }')
} catch (error) {
      if (error instanceof ReadError) {
            console.log(`${error.name}: ${error.cause}`)
      } else throw error
}


----------------------
* 4. Промисификация   
----------------------

function promisify(fn, manyArgs = false) {
      return function (...args) {
            return new Promise((resolve, reject) => {
                  function callback(error, ...results) {
                        if (error) reject(error)
                        else resolve(manyArgs ? results : results[0])
                  }
    
                  args.push(callback)
    
                  fn.call(this, ...args)
            })
      }
}
    
fn = promisify(fn, true)
fn(...).then(arrayOfResults => {...}, error => {...})
